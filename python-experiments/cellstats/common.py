# Copyright 2022 Flavien Solt, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

import json
import os
from common.enums import InstrumentationMethod

def get_design_names():
    return [
        "ibex",
        "rocket",
        "pulpissimo",
        "cva6",
        "boom"
    ]

cell_types = [
    "not",
    "and",
    "or",
    "mux",

    "ge",
    "gt",
    "le",
    "lt",

    "r_and",
    "r_or",
    "add",
    "eq",
    "ne",
    "neg",
    "sub",
    "xor",
    "r_xor",
    "ff",
    "ffe",
    "ffce",
    "dlatch",
    "shr",
    "sshr",
    "shift",
    "shl",
    "mul"
]

cell_types_extended = [
    "ge",
    "gt",
    "le",
    "lt",
    "r_and",
    "r_or",
    "add",
    "eq",
    "ne",
    "neg",
    "sub",
    "not",
    "and",
    "or",
    "mux",
    "xor",
    "r_xor",
    "ff",
    "ffe",
    "ffce",
    "dlatch",
    "shr",
    "sshr",
    "shift",
    "shl",
    "mul",
    "ignored", # For buffers that do not impact performance and precision
    None # For unexpected cell types
]

cell_type_map = {
    "_ANDNOT_": None,
    "_AND_": "and",
    "_AOI3_": None,
    "_AOI4_": None,
    "_BUF_": "ignored",
    "_DFFE_NN0N_": "ffe",
    "_DFFE_NN0P_": "ffe",
    "_DFFE_NN1N_": "ffe",
    "_DFFE_NN1P_": "ffe",
    "_DFFE_NN_": "ffe",
    "_DFFE_NP0N_": "ffe",
    "_DFFE_NP0P_": "ffe",
    "_DFFE_NP1N_": "ffe",
    "_DFFE_NP1P_": "ffe",
    "_DFFE_NP_": "ffe",
    "_DFFE_PN0N_": "ffe",
    "_DFFE_PN0P_": "ffe",
    "_DFFE_PN1N_": "ffe",
    "_DFFE_PN1P_": "ffe",
    "_DFFE_PN_": "ffe",
    "_DFFE_PP0N_": "ffe",
    "_DFFE_PP0P_": "ffe",
    "_DFFE_PP1N_": "ffe",
    "_DFFE_PP1P_": "ffe",
    "_DFFE_PP_": "ffe",
    "_DFFSRE_NNNN_": "ffe",
    "_DFFSRE_NNNP_": "ffe",
    "_DFFSRE_NNPN_": "ffe",
    "_DFFSRE_NNPP_": "ffe",
    "_DFFSRE_NPNN_": "ffe",
    "_DFFSRE_NPNP_": "ffe",
    "_DFFSRE_NPPN_": "ffe",
    "_DFFSRE_NPPP_": "ffe",
    "_DFFSRE_PNNN_": "ffe",
    "_DFFSRE_PNNP_": "ffe",
    "_DFFSRE_PNPN_": "ffe",
    "_DFFSRE_PNPP_": "ffe",
    "_DFFSRE_PPNN_": "ffe",
    "_DFFSRE_PPNP_": "ffe",
    "_DFFSRE_PPPN_": "ffe",
    "_DFFSRE_PPPP_": "ffe",
    "_DFFSR_NNN_": "ff",
    "_DFFSR_NNP_": "ff",
    "_DFFSR_NPN_": "ff",
    "_DFFSR_NPP_": "ff",
    "_DFFSR_PNN_": "ff",
    "_DFFSR_PNP_": "ff",
    "_DFFSR_PPN_": "ff",
    "_DFFSR_PPP_": "ff",
    "_DFF_NN0_": "ff",
    "_DFF_NN1_": "ff",
    "_DFF_NP0_": "ff",
    "_DFF_NP1_": "ff",
    "_DFF_N_": "ff",
    "_DFF_PN0_": "ff",
    "_DFF_PN1_": "ff",
    "_DFF_PP0_": "ff",
    "_DFF_PP1_": "ff",
    "_DFF_P_": "ff",
    "_DLATCHSR_NNN_": "dlatch",
    "_DLATCHSR_NNP_": "dlatch",
    "_DLATCHSR_NPN_": "dlatch",
    "_DLATCHSR_NPP_": "dlatch",
    "_DLATCHSR_PNN_": "dlatch",
    "_DLATCHSR_PNP_": "dlatch",
    "_DLATCHSR_PPN_": "dlatch",
    "_DLATCHSR_PPP_": "dlatch",
    "_DLATCH_NN0_": "dlatch",
    "_DLATCH_NN1_": "dlatch",
    "_DLATCH_NP0_": "dlatch",
    "_DLATCH_NP1_": "dlatch",
    "_DLATCH_N_": "dlatch",
    "_DLATCH_PN0_": "dlatch",
    "_DLATCH_PN1_": "dlatch",
    "_DLATCH_PP0_": "dlatch",
    "_DLATCH_PP1_": "dlatch",
    "_DLATCH_P_": "dlatch",
    "_FF_": "ff",
    "_MUX16_": "mux",
    "_MUX4_": "mux",
    "_MUX8_": "mux",
    "_MUX_": "mux",
    "_NAND_": None,
    "_NMUX_": None,
    "_NOR_": None,
    "_NOT_": "not",
    "_OAI3_": None,
    "_OAI4_": None,
    "_ORNOT_": None,
    "_OR_": "or",
    "_SDFFCE_NN0N_": "ffce",
    "_SDFFCE_NN0P_": "ffce",
    "_SDFFCE_NN1N_": "ffce",
    "_SDFFCE_NN1P_": "ffce",
    "_SDFFCE_NP0N_": "ffce",
    "_SDFFCE_NP0P_": "ffce",
    "_SDFFCE_NP1N_": "ffce",
    "_SDFFCE_NP1P_": "ffce",
    "_SDFFCE_PN0N_": "ffce",
    "_SDFFCE_PN0P_": "ffce",
    "_SDFFCE_PN1N_": "ffce",
    "_SDFFCE_PN1P_": "ffce",
    "_SDFFCE_PP0N_": "ffce",
    "_SDFFCE_PP0P_": "ffce",
    "_SDFFCE_PP1N_": "ffce",
    "_SDFFCE_PP1P_": "ffce",
    "_SDFFE_NN0N_": "ffe",
    "_SDFFE_NN0P_": "ffe",
    "_SDFFE_NN1N_": "ffe",
    "_SDFFE_NN1P_": "ffe",
    "_SDFFE_NP0N_": "ffe",
    "_SDFFE_NP0P_": "ffe",
    "_SDFFE_NP1N_": "ffe",
    "_SDFFE_NP1P_": "ffe",
    "_SDFFE_PN0N_": "ffe",
    "_SDFFE_PN0P_": "ffe",
    "_SDFFE_PN1N_": "ffe",
    "_SDFFE_PN1P_": "ffe",
    "_SDFFE_PP0N_": "ffe",
    "_SDFFE_PP0P_": "ffe",
    "_SDFFE_PP1N_": "ffe",
    "_SDFFE_PP1P_": "ffe",
    "_SDFF_NN0_": "ff",
    "_SDFF_NN1_": "ff",
    "_SDFF_NP0_": "ff",
    "_SDFF_NP1_": "ff",
    "_SDFF_PN0_": "ff",
    "_SDFF_PN1_": "ff",
    "_SDFF_PP0_": "ff",
    "_SDFF_PP1_": "ff",
    "_SR_NN_": "ff",
    "_SR_NP_": "ff",
    "_SR_PN_": "ff",
    "_SR_PP_": "ff",
    "_TBUF_": None,
    "_XNOR_": "xor",
    "_XOR_": "xor",
    "add": "add",
    "adff": "ff",
    "adffe": "ffe",
    "adlatch": "dlatch",
    "allconst": None,
    "allseq": None,
    "alu": None,
    "and": "and",
    "anyconst": None,
    "anyseq": None,
    "assert": "ignored",
    "assume": "ignored",
    "concat": "ignored",
    "cover": "ignored",
    "dff": "ff",
    "dffe": "ffe",
    "dffsr": "ff",
    "dffsre": "ffe",
    "div": None,
    "divfloor": None,
    "dlatch": "dlatch",
    "dlatchsr": "dlatch",
    "eq": "eq",
    "equiv": None,
    "eqx": None,
    "fa": None,
    "fair": None,
    "ff": "ff",
    "fsm": None,
    "ge": "ge",
    "gt": "gt",
    "initstate": None,
    "lcu": None,
    "le": "le",
    "live": None,
    "logic_and": "r_and",
    "logic_not": "r_or",
    "logic_or": "r_or",
    "lt": "lt",
    "lut": None,
    "macc": None,
    "mem": None,
    "mem_v2": None,
    "meminit": None,
    "meminit_v2": None,
    "memrd": None,
    "memrd_v2": None,
    "memwr": None,
    "memwr_v2": None,
    "mod": None,
    "modfloor": None,
    "mul": "mul",
    "mux": "mux",
    "ne": "ne",
    "neg": "neg",
    "nex": None,
    "not": "not",
    "or": "or",
    "pmux": None,
    "pos": "ignored",
    "pow": None,
    "reduce_and": "r_and",
    "reduce_bool": "r_or",
    "reduce_or": "r_or",
    "reduce_xnor": "r_xor",
    "reduce_xor": "r_xor",
    "sdff": "ff",
    "sdffce": "ffe",
    "sdffe": "ffe",
    "shift": "shift",
    "shiftx": "shift",
    "shl": "shl",
    "shr": "shr",
    "slice": None,
    "sop": None,
    "specify2": None,
    "specify3": None,
    "specrule": None,
    "sr": "ff",
    "sshl": "shl",
    "sshr": "sshr",
    "sub": "sub",
    "tribuf": None,
    "xnor": "xor",
    "xor": "xor"
}

def check_cell_type_map():
    for elem_id, elem in cell_type_map:
        assert elem in cell_types_extended

# @param cell_str: given in the statistics file, key of the cell_type_map array.
# @returrn an element of the cell_types_extended array.
def get_cell_type_by_str(cell_str):
    assert cell_str in cell_type_map, "Unknown cell type: {}".format(cell_str)
    elem = cell_type_map[cell_str]
    assert cell_str is not None, "Cell type `{}` is mapped to nothing.".format(cell_str)
    return elem

# We need to passthrough to get the Vanilla cells, therefore, Passthrough and Vanilla are equivalent in some cases and we do not need both.
def get_instrumentation_methods_novanilla():
    return [
        InstrumentationMethod.PASSTHROUGH,
        InstrumentationMethod.CELLIFT,
        InstrumentationMethod.GLIFT
    ]

def get_instrumentation_methods_nopassthrough():
    return [
        InstrumentationMethod.VANILLA,
        InstrumentationMethod.CELLIFT,
        InstrumentationMethod.GLIFT
    ]
