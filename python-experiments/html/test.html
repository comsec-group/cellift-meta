<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
      font-family:"avenir next", Arial, sans-serif;
      font-size: 12px;
      color: #696969;
    }

    #play-button {
      position: absolute;
      top: 140px;
      left: 50px;
      background: #f08080;
      padding-right: 26px;
      border-radius: 3px;
      border: none;
      color: white;
      margin: 0;
      padding: 0 12px;
      width: 60px;
      cursor: pointer;
      height: 30px;
    }

    #back-button {
      position: absolute;
      top: 140px;
      left: 150px;
      background: #f08080;
      padding-right: 26px;
      border-radius: 3px;
      border: none;
      color: white;
      margin: 0;
      padding: 0 12px;
      width: 60px;
      cursor: pointer;
      height: 30px;
    }

    #step-button {
      position: absolute;
      top: 140px;
      left: 250px;
      background: #f08080;
      padding-right: 26px;
      border-radius: 3px;
      border: none;
      color: white;
      margin: 0;
      padding: 0 12px;
      width: 60px;
      cursor: pointer;
      height: 30px;
    }

    #play-button:hover {
      background-color: #696969;
    }    
    
    .ticks {
      font-size: 10px;
    }

    .track,
    .track-inset,
    .track-overlay {
      stroke-linecap: round;
    }

    .track {
      stroke: #000;
      stroke-opacity: 0.3;
      stroke-width: 10px;
    }

    .track-inset {
      stroke: #dcdcdc;
      stroke-width: 8px;
    }

    .track-overlay {
      pointer-events: stroke;
      stroke-width: 50px;
      stroke: transparent;
      cursor: crosshair;
    }

    .handle {
      fill: #fff;
      stroke: #000;
      stroke-opacity: 0.5;
      stroke-width: 1.25px;
    }

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

text {
  font-family: sans-serif;
  font-size: 10px;
}

</style>

<div id="vis">
  <button id="play-button">Play</button>
  <button id="back-button">Back</button>
  <button id="step-button">Step</button>

 <label for="traces">Visualize execution trace:</label>
 <select name="traces" id="traces">
 <option value="meltdown-forbidden">BOOMv2 Forbidden Load</option>
 <option value="spectre-nofdiv">Spectre without fdiv</option>
 </select> 

</div>

<svg width="1500" height="1200"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>


var svg = d3.select("svg"),
    svg_width = +svg.attr("width"),
    svg_height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(svg_width / 2, svg_height / 2));


////////// slider //////////

var margin = {top:50, right:50, bottom:0, left:50},
    slider_width = svg_width - margin.left - margin.right,
    slider_height = svg_height - margin.top - margin.bottom;

var slider_moving = false;
var currentValue = 0;
var targetValue = slider_width;

var playButton = d3.select("#play-button");
var stepButton = d3.select("#step-button");
var backButton = d3.select("#back-button");

var formatDateIntoYear = d3.timeFormat("%Y");
var formatDate = d3.timeFormat("%b %Y");
var parseDate = d3.timeParse("%m/%d/%y");

var startDate = new Date("2004-11-01"),
    endDate = new Date("2017-04-01");

var slider = svg.append("g")
    .attr("class", "slider")
    .attr("transform", "translate(" + margin.left + "," + slider_height/5 + ")");

var x;

function set_targetvalue(t) {
	targetValue = t;
x = d3.scaleTime()
    .domain([startDate, endDate])
    .range([0, targetValue])
    .clamp(true);
  frameupdate(currentValue, x.invert(currentValue));
}

var circles = 0;

var frame_dataset = 0;

set_targetvalue(slider_width);

function frameupdate(f, h) {
  // update position and text of label according to slider scale
  if(frame_dataset == 0 || circles == 0) return;
  cycle = f;
  if(cycle < 0) cycle = 0;
  if(cycle >= frame_dataset.length) cycle = frame_dataset.length-1;
  var this_frame = frame_dataset[cycle];
  console.log('frame_dataset: ' + this_frame + ' frame cycle: ' + cycle + ' / ' + frame_dataset.length);
	circles.attr("fill", function(d) {
			sigid = d.sigid;
			if(sigid < 0) { return color(1); }
			tv = this_frame[sigid];
			if(tv == 0) {  return color(0); } 
		        cn = 2 + (tv % 17);
			return color(cn);
		}
  	).
		attr("r", function(d) { if(d.sigid < 0) return 3; if(this_frame[d.sigid] > 0) { return 12; } else { return 6; } } )
	;
  handle.attr("cx", x(h));
  label
    .attr("x", x(h))
    .text(f);
}

function step() {
  if(frame_dataset == 0) return;
  currentValue = currentValue + 1;
  frameupdate(currentValue, x.invert(currentValue));
//    console.log("value: " + currentValue);
  if (currentValue > targetValue || currentValue < 0) {
	  if(slider_moving) {
	    slider_moving = false;
	    clearInterval(timer);
	  }
    currentValue = 0;
    frameupdate(currentValue, x.invert(currentValue));
    // timer = 0;
    playButton.text("Play");
    stepButton.text("Step");
    console.log("Slider moving: " + slider_moving);
  }
}

playButton.on("click", function() {
    var button = d3.select(this);
    if (button.text() == "Pause") {
      slider_moving = false;
      clearInterval(timer);
      // timer = 0;
      button.text("Play");
    } else {
      slider_moving = true;
      timer = setInterval(step, 200);
      button.text("Pause");
    }
    console.log("Slider moving: " + slider_moving);
  });


stepButton.on("click", function() {
    var button = d3.select(this);

    if(slider_moving) {
	    slider_moving = false;
      	    clearInterval(timer);
   }
   step();
});

backButton.on("click", function() {
    var button = d3.select(this);

    if(slider_moving) {
	    slider_moving = false;
      	    clearInterval(timer);
   }
   currentValue -= 2; // XXX hack to re-use step()
   step();
});

slider.append("line")
    .attr("class", "track")
    .attr("x1", x.range()[0])
    .attr("x2", x.range()[1])
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-inset")
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-overlay")
    .call(d3.drag()
        .on("start.interrupt", function() { slider.interrupt(); })
        .on("start drag", function() {
          currentValue = d3.event.x;
	  if(currentValue < 0) currentValue = 0;
	  if(currentValue > targetValue) currentValue = targetValue;
          frameupdate(currentValue, x.invert(currentValue)); 
        })
    );

slider.insert("g", ".track-overlay")
    .attr("class", "ticks")
    .attr("transform", "translate(0," + 18 + ")")
  .selectAll("text")
    .data(x.ticks(10))
    .enter()
    .append("text")
    .attr("x", x)
    .attr("y", 10)
    .attr("text-anchor", "middle")
    .text(function(d) { return " " + Math.trunc(x(d)); });

var handle = slider.insert("circle", ".track-overlay")
    .attr("class", "handle")
    .attr("r", 9);

var label = slider.append("text")  
    .attr("class", "label")
    .attr("text-anchor", "middle")
    .text("0")
    .attr("transform", "translate(0," + (-25) + ")")

///////////

var hash = window.location.hash.substr(1);

d3.json("big.json", function(error, graph) {
  if (error) throw error;

	frame_dataset = graph['matrix'];


  var link = svg.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line");
//      .attr("stroke-width", function(d) { return Math.sqrt(d.value); });

  var node = svg.append("g")
      .attr("class", "nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter().append("g")

  circles = node.append("circle")
    .attr("r", 5)
    .attr("fill", function(d) { return color(0); });

set_targetvalue(frame_dataset.length);


  // Create a drag handler and append it to the node object instead
  var drag_handler = d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);

  drag_handler(node);
  
  var lables = node.append("text")
      .text(function(d) {
        return d.id;
      })
      .attr('x', 6)
      .attr('y', 3);

  node.append("title")
      .text(function(d) { return d.id; });

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

groupno=1;

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        })
  }

});

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

</script>
